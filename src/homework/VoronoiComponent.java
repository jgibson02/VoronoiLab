package homework;

import java.awt.BasicStroke;
import java.awt.Cursor;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.geom.Line2D;
import java.util.ArrayList;
import java.util.Random;
import javax.swing.JComponent;
import java.awt.Point;
import java.awt.RenderingHints;

/**
 * Generates a Voronoi diagram generated by clicking on points in the workspace,
 * also supports distance calculation in any number of dimensions.
 * Painting the component using a distance metric besides Euclidian and Manhattan distance
 * results in prolonged rendering times due to more complex calculations.
 * Also seems to take an *extreme* amount of time on Windows 7 computers in the software
 * lab, for reasons I have been unable to determine.
 * @author John Gibson
 * @version Mar 28, 2016
 */
public class VoronoiComponent extends JComponent {
    
    private final ArrayList<Seed> seedList = new ArrayList<>();
    private int q = 2;  // Minkowski Coefficient
    private int seedCount = 0;
    private static final int INIT_OPACITY = 75;
    private int opacity = INIT_OPACITY;
    private final Random rand = new Random();
    private boolean showSeeds = true;
    private boolean distanceVisualization = false;
    private boolean showDelaunayTriangles = false;
    private boolean showCircumcircles = false;
    private Seed closestSeed;
    private Seed cursorSeed;
    private int w;
    private int h;
    private double minimumDistance = Double.MAX_VALUE;
    private double maximumDistance;
    private static double seedRadius;
    
    public VoronoiComponent() {
        /**
         * Creates a listener for user clicks to add the seed to the seed registry,
         * as well as a movement listener to check if the user has hovered over a 
         * seed.
         */
        class Listener extends MouseAdapter {
            @Override
            public void mousePressed(MouseEvent e) {
                if (cursorSeed != null && cursorSeed.getCircle().contains(e.getPoint())) {
                    int index = 0;
                    for (int i = 0; i < seedList.size(); i++) {
                        if (seedList.get(i) == cursorSeed) {
                            index = i;
                        }
                    }
                    seedList.remove(index);
                    seedCount--;
                    mouseMoved(e);
                } else {
                    addSeed(new Point(e.getPoint()));
                }
                repaint();
            }
            @Override
            public void mouseMoved(MouseEvent e) {
                for (Seed seed : seedList) {
                    if (seed.getCircle().contains(e.getPoint())) {
                        cursorSeed = seed;
                        setCursor(new Cursor(Cursor.HAND_CURSOR));
                        repaint();
                        break;
                    } else {
                        if (cursorSeed != null) {
                            cursorSeed = null;
                            repaint();
                        }                        
                        setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
                    }
                }
            }
        }
        Listener listener = new Listener();
        addMouseListener(listener);
        addMouseMotionListener(listener);
    }
    
    @Override
    public void paintComponent(Graphics g) {
        Graphics2D g2 = (Graphics2D) g;
        g2.addRenderingHints(new RenderingHints(RenderingHints.KEY_RENDERING, 
                RenderingHints.VALUE_RENDER_SPEED));
                
        w = getWidth();
        h = getHeight();
        seedRadius = w / 120;
        
        // paint dark-gray background
        g2.setColor(Color.DARK_GRAY);
        Rectangle bg = new Rectangle(w, h);
        g2.fill(bg);
        
        //-------------------- paint the Voronoi cells -----------------------//
        if (seedCount > 0) {
            g2.setColor(Color.WHITE);
            g2.fill(bg);
            for (int i = 0; i < w; i++) {
                for (int j = 0; j < h; j++) {
                    double minDistance = w * h;
                    Point thisPoint = new Point(i, j);
                    for (Seed s : seedList) {
                        double distance = getDistance(s.getPoint(), thisPoint);
                        if (distance <= minDistance) {
                            minDistance = distance;
                            closestSeed = s;
                        }
                    }
                    if (distanceVisualization) {
                        int rgb = (int) ((255 * minDistance)/(Math.max(w, h)));
                        if (rgb < 0) {
                            rgb = 0;
                        } else if (rgb > 255) {
                            rgb = 255;
                        }
                        Color c = new Color(rgb, rgb, rgb);
                        g2.setColor(c);
                    } else {
                        g2.setColor(closestSeed.getColor());
                    }
                    g2.fillRect(i, j, 1, 1);
                }
            }
            
            //-------------- paint the Delaunay Triangulization --------------//
            for (int i = 0; i < seedCount - 2; i++) {
                for (int j = i + 1; j < seedCount - 1; j++) {
                    for (int k = j + 1; k < seedCount; k++) {
                        boolean isDelaunay = true;
                        Ellipse2D.Double circumcircle = new Ellipse2D.Double(0, 0, 0, 0);
                        Seed iSeed = seedList.get(i);
                        Seed jSeed = seedList.get(j);
                        Seed kSeed = seedList.get(k);
                        Point iPoint = iSeed.getPoint();
                        Point jPoint = jSeed.getPoint();
                        Point kPoint = kSeed.getPoint();
                        for (int n = 0; n < seedCount; n++) {
                            if (n == i || n == j || n == k) continue;
                            circumcircle = new Ellipse2D.Double(iPoint, jPoint, kPoint);
                            if (circumcircle.contains(seedList.get(n).getPoint())) {
                                isDelaunay = false;
                            }
                        }
                        if (isDelaunay && showCircumcircles) {
                            BasicStroke circleStroke = new BasicStroke(3, 
                            BasicStroke.CAP_ROUND, BasicStroke.JOIN_MITER);
                            g2.setStroke(circleStroke);
                            if (iSeed == cursorSeed || jSeed == cursorSeed || kSeed == cursorSeed) {
                                g2.setColor(Color.RED);
                            } else {
                                g2.setColor(Color.BLACK);
                            }
                            g2.draw(circumcircle);
                        }
                        if (isDelaunay && showDelaunayTriangles) {
                            g2.setStroke(new BasicStroke(3, BasicStroke.CAP_ROUND, 
                                    BasicStroke.JOIN_MITER));
                            if (cursorSeed != null && (iPoint == cursorSeed.getPoint() || 
                                    jPoint == cursorSeed.getPoint() || 
                                    kPoint == cursorSeed.getPoint())) {
                                g2.setColor(Color.WHITE);
                            } else {
                                g2.setColor(Color.RED);
                            }
                            g2.draw(new Line2D.Double(iPoint.getX(), iPoint.getY(), 
                                jPoint.getX(), jPoint.getY()));
                            g2.draw(new Line2D.Double(iPoint.getX(), iPoint.getY(), 
                                kPoint.getX(), kPoint.getY()));
                            g2.draw(new Line2D.Double(jPoint.getX(), jPoint.getY(), 
                                kPoint.getX(), kPoint.getY()));
                        }
                    }
                }
            }
            
            //------------------------ paint the seeds -----------------------//
            if (showSeeds) {
                for (Seed s : seedList) {
                    Point p = s.getPoint();
                    double x = p.x;
                    double y = p.y;
                    if (distanceVisualization) {
                        g2.setColor(Color.WHITE);
                    } else if (s == cursorSeed) {
                        g2.setColor(Color.LIGHT_GRAY);
                    } else {
                        g2.setColor(Color.invertColor(s.getColor()));
                    }
                    g2.fill(s.getCircle());
                }
            }
        }
    }
    
    private double getEuclidianDistance(Point p1, Point p2) {
        double x1 = p1.getX();
        double y1 = p1.getY();
        double x2 = p2.getX();
        double y2 = p2.getY();
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
    
    /**
     * Calculates the distance between two points using one of three distance 
     * calculation methods.
     */
    public double getDistance(Point p1, Point p2) {
        double x1 = p1.getX();
        double y1 = p1.getY();
        double x2 = p2.getX();
        double y2 = p2.getY();
        
        if (q == 1) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        } else if (q == 2) {
            return getEuclidianDistance(p1, p2);
        } else {
            // This mess of a formula is to calculate Minkowski Distance with q 
            // as lambda. This works for Euclidian and Manhattan, but I've
            // decided to use this only for cases of q >= 3 due to long
            // rendering times.
            return Math.pow((Math.pow(Math.abs(x1 - x2), q) + 
                    (Math.pow(Math.abs(y1 - y2), q))), (double) 1/q);
        }
    }
    
    public int getInitOpacity() {
        return INIT_OPACITY;
    }
    
    public double getMaximumDistance() {
        return maximumDistance;
    }
    
    public double getMinimumDistance() {
        return minimumDistance;
    }
    
    public int getMinkowskiCoefficient() {
        return q;
    }
    
    public int getSeedCount() {
        return seedCount;
    }
    
    public ArrayList<Seed> getSeedList() {
        return seedList;
    }
    
    public void setCursorSeed(Seed s) {
        cursorSeed = s;
    }
    
    public void setMinkowskiCoefficient(int q) {
        this.q = q;
        repaint();
    }
    
    public void setOpacity(int alpha) {
        opacity = alpha;
        seedList.stream().forEach((Seed s) -> {
            Color c = s.getColor();
            int r = c.getRed();
            int g = c.getGreen();
            int b = c.getBlue();
            s.setColor(new Color(r, g, b, opacity));
        });
        repaint();
    }
    
    public void setShowCircumcircles(boolean b) {
        showCircumcircles = b;
        repaint();
    }
    
    public void setShowDelaunayTriangles(boolean b) {
        showDelaunayTriangles = b;
        repaint();
    }
    
    public void setShowDistanceVisualization(boolean b) {
        distanceVisualization = b;
        repaint();
    }
    
    public void setShowSeeds(boolean b) {
        showSeeds = b;
        repaint();
    }
    
    /**
     * Creates and registers a seed based on the point where the user has clicked.
     */
    public void addSeed(Point p) {
        seedList.add(new Seed(p, seedRadius, Color.getRandomColor()));
        setOpacity(opacity);
        seedCount++;
        updateMinMax();
    }
    
    /**
     * Resets the seeds registry.
     */
    public void clearPoints() {
        seedList.clear();
        seedCount = 0;
        updateMinMax();
        repaint();
    }
    
    /**
     * Calculates the shortest and greatest distance between any pair of seeds.
     */
    private void updateMinMax() {
        seedList.stream().forEach((Seed s1) -> {
            seedList.stream().map((s2) -> getEuclidianDistance(s1.getPoint(), s2.getPoint())).filter((dist) -> (dist != 0)).map((dist) -> {
                if (dist < minimumDistance) {
                    minimumDistance = dist;
                }
                return dist;
            }).filter((dist) -> (dist > maximumDistance)).forEach((dist) -> {
                maximumDistance = dist;
            });
        });
        if (seedCount == 0) {
            minimumDistance = 0;
            maximumDistance = 0;
        }
    }
    
    /**
     * Sets each seed's color to a random color.
     */
    public void randomizeColors() {
        seedList.stream().forEach((s) -> {
            s.setColor(new Color( Color.getRandomColor()));
        });
        setOpacity(opacity);
    }
}